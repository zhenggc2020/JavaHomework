##  题目 01- 请你说一说什么是线程和进程？

- 区别
  - 进程是系统运行程序的基本单位, 是系统分配资源的最小单元,一个程序至少包含一个进程;每个进程都有自己独立的内存空间,一个进程包含多个线程;
  - 线程是操作系统调度的最小单元;   多线程之间的堆内存与方法区是共享的;每个线程的栈空间和程序计数器是独立的;
- 关系
  - 线程是进程的一个执行单元,  一个进程至少包含一个线程. 进程在运行中会产生多个线程. 
  - 多个线程 共享进程内的堆空间,
- 线程的上下文切换是什么？
  - 一个CPU内核,同一时刻只能运行一个线程. 为了提升CPU利用率, CPU采用了时间片算法将CPU时间片轮流分配给多个线程.,当一个CPU内核,进行线程切换时,  需要将当前任务状态信息保存到内存中,  然后加载下一个任务的状态信息;
  - 任务状态的保存以及再加载的过程称为上下文切换;
- 线程的并发与并行有啥区别？
  - 同一个时间段内有多个任务都在运行, 但不一定都在同一个时刻运行, 称为并发.
  - 同一个时间段内,有多个任务同时运行, 称为并行.   并行与多核CUP的核数直接相关联.

##  题目 02- 使用了多线程会带来什么问题呢？

- 能不能详细说说线程安全问题？
  - 在并发场景下,程序按照我们期望的方式执行, 可以称为是线程安全的.
  - 多个线程同时执行一块代码, 如果程序每次运行的结果与单线程的执行结果一致, 且相关变量值也与单线程执行的结果一致, 我们称之为线程安全的.
  - 线程安全问题都是由共享变量引发的.
  - 解决线程安全的方法有 
    - 线程同步,
    - valatile
    - synchronized     JUC 锁 与JUC 元子类;
- 原子性、有序性和可见性能不能深入的谈一下。
  - 一个或多个操作在CPU执行的过程中不被中断的特性称为原子性.  CPU能保证的原子操作是CPU执行级别的, 而不是高级语言的操作符,而且很多时候,我们需要在高级语言层面保证操作的原子性.
    - 操作系统增加了进程,线程,以分时复用CPU,提高CPU的利用率, CPU的任务切换,会带来原子性问题.
  - 一个线程对共享变量的修改,另外一个线程能够立刻看到, 我们成为可见性.
    - 多核时代,每个CPU都有自己的缓存, 这时候CPU的缓存与不同线程的共享内存的数据不一致, 就会引发可见性问题.
  - 程序代码按照先后顺序执行, 我们成为有序性.
    - 编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。 这个指令重排序, 在并发场景下, 可能会引发有序性问题

##  题目 03- 什么是死锁？如何排查死锁?

- 排查过程最好详细说明，最少说一种排查方案，越多越好。
  - 一组互相竞争资源的线程因互相等待,导致永久阻塞的现象,称为死锁.
  - 排查过程如下:
  - 首先先确定, 是不是使用多把锁(两把以及两把以上),  保护有关联关系的多个资源. 
  - 然后依次判断造成死锁的四个条件是不是可能都发生. 
    - 互斥，共享资源 X 和 Y 只能被一个线程占用；
    - 占有且等待，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；
    - 不可抢占，其他线程不能强行抢占线程 T1 占有的资源；
    - 循环等待，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。
  - 以上四个条件只要有一个肯定不满足, 则不会出现死锁,  如果某一时刻,四个全部都成立, 则会出现死锁.





