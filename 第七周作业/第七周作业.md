###  题目 01- 完成 ReadView 案例，解释为什么 RR 和 RC 隔离级别下看到查询结果不一致
要求：

- 完成**案例 01- 读已提交 RC 隔离级别下的可见性分析**
- 完成**案例 02- 可重复读 RR 隔离级别下的可见性分析**
- 用通俗易懂的方式记录整个案例过程，可以画图与截图
- 做完案例给出结论，并对结论进行分析

####  案例 01- 读已提交 RC 隔离级别下的可见性分析

- 目标
  - 读已提交RC隔离级别下的可见性分析

- 操作步骤
  - 初始准备;首先创建表,并添加一条记录如下
  - ![image-20231001150659859](.\附件\image-20231001150659859.png)
  - 第1步:开启三个查询窗口, 并执行如下sql语句; 开启RC隔离级别;
    - -- 设置数据库的隔离级别
      set session transaction isolation level read committed;
      -- 查询事务隔离级别：
      select @@tx_isolation;
    - 截图如下:
    - ![image-20231001150945466](.\附件\image-20231001150945466.png)

  - 第2步: 然后, 三个窗口全部执行开启事务;
    - start transaction ;

  - 第3步: 然后第一个窗口执行更新为关羽,   第二个窗口执行更新为  赵云,  第三个窗口执行查询数据;  截图如下
    - ![image-20231001151327314](.\附件\image-20231001151327314.png)
    - ![image-20231001151312666](.\附件\image-20231001151312666.png)
    - ![image-20231001151409106](.\附件\image-20231001151409106.png)
    - 此时,可以发现,第二个窗口发生锁等待,  第三个窗口查询出事务开启前的默认数据;   刘备的信息;

  - 第4步; 提交第一个窗口的事务; 第三个窗口再次执行查询;
    - ![image-20231001151910845](.\附件\image-20231001151910845.png)
    - 此时,可以发现, 第三个窗口,查出了第一个窗口提交的修改数据;
    - 此时,第二个窗口;执行更新赵云成功;

  - 第5步; 提交第二个窗口的事务; 第三个窗口再次执行查询;
    - ![image-20231001152103843](.\附件\image-20231001152103843.png)
    - 此时可以发现, 第三个窗口,查出了第二个窗口提交的修改数据;   

- 结论
  - 综合以上情况, 得出结论;
    - 使用RC隔离级别的事务,在每次查询开始的时候都会生成一个独立的ReadView.


####  案例 02- 可重复读 RR 隔离级别下的可见性分析

- 目标
  - 读已提交RR 隔离级别下的可见性分析
- 操作步骤
  - 初始准备;首先创建表,并添加一条记录如下
  - ![image-20231001150659859](.\附件\image-20231001150659859.png)
  - 第1步:开启三个查询窗口, 并执行如下sql语句; 开启RR隔离级别;
    - -- 设置数据库的隔离级别
      set session transaction isolation level repeatable read ;
      -- 查询事务隔离级别：
      select @@tx_isolation;
    - 截图如下:
    - ![image-20231001152443915](.\附件\image-20231001152443915.png)
  - 第2步: 然后, 三个窗口全部执行开启事务;
    - start transaction ;
  - 第3步: 然后首先使用第三个窗口,执行查询语句获取数据 ,第一个窗口执行更新为关羽,   第二个窗口执行更新为  赵云,  第三个窗口执行查询数据;  截图如下
    - ![image-20231001153002646](.\附件\image-20231001153002646.png)
    - ![image-20231001151327314](.\附件\image-20231001151327314.png)
    - ![image-20231001151312666](.\附件\image-20231001151312666.png)
    - 此时,可以发现,第二个窗口发生锁等待,  第三个窗口查询出默认数据;   刘备的信息;
  - 第4步; 提交第一个窗口的事务; 第三个窗口再次执行查询;
    - ![image-20231001153107210](.\附件\image-20231001153107210.png)
    - 此时,可以发现, 第三个窗口,查出的依然是 初始的默认数据;
    - 此时,第二个窗口;执行更新赵云成功;
  - 第5步; 提交第二个窗口的事务; 第三个窗口再次执行查询;
    - ![image-20231001153150885](.\附件\image-20231001153150885.png)
    - 此时可以发现, 第三个窗口,查出的还是默认的数据, 刘备;
  - 第6步; 提交第三个窗口的事务;  第三个窗口再次执行查询; 
    - ![image-20231001153301223](.\附件\image-20231001153301223.png)
    - 此时发现第三个窗口的事务; 查出了第二个窗口成功提交的更改数据, 赵云的信息;
- 结论
  - 综合以上情况, 得出结论;
    - 在事务开始后第一次读取数据时生成一个ReadView。对于使用 RR 隔离级别的事务来说，只会在第一次执行查询语句时生成一个 ReadView ，之后的查询就不会重复生成了。

#### 结论分析

- 分析:
  - 使用RC隔离级别的事务,在每次查询开始的时候都会生成一个独立的ReadView.
  - 在事务开始后第一次读取数据时生成一个ReadView。对于使用 RR 隔离级别的事务来说，只会在第一次执行查询语句时生成一个 ReadView ，之后的查询就不会重复生成了。


###  题目 02- 什么是索引？

- 优点是什么？
  - 可以加速数据库数据的查询速度.

- 缺点是什么？
  - 索引需要额外的物理存储空间;

- 索引分类有哪些？特点是什么？
  - 索引分为如下索引;
    - 聚簇索引
    - 覆盖索引
    - 组合索引
    - 前缀索引
    - 唯一索引

- 索引创建的原则是什么？
  - 频繁出现在where 条件字段，order排序，group by分组字段
  - select 频繁查询的列，考虑是否需要创建联合索引（覆盖索引，不回表）
  - 多表join关联查询，on字段两边的字段都要创建索引

- 有哪些使用索引的注意事项？
  - 表记录很少不需创建索引
  - 一个表的索引个数不能过多
  - 频繁更新的字段不建议作为索引
  - 区分度低的字段，不建议建索引
  - 不建议用无序的值作为索引
  - 尽量创建组合索引，而不是单列索引;

- 如何知道 SQL 是否用到了索引？
  - 使用explain 分析查询语句;
  - ![image-20231001160748245](.\附件\image-20231001160748245.png)
  - 结合 key 与extra项,  判断sql是否用到了索引;

- 请你解释一下索引的原理是什么？「重点」
  - mysql的Inodb引擎使用B+树,存储索引;因为B+树,有如下优点
    - B+树的节点中存储着多个元素，每个节点内有多个分叉。
    - 节点中的元素包含键值和数据，节点中的键值从大到小排列。也就是说，在所有的节点都储存数据。
    - 父节点当中的元素不会出现在子节点中。
    - 所有的叶子结点都位于同一层，叶节点具有相同的深度，叶节点用指针连接。
    - 所以B+树,具备了, 范围搜索,与等值查询.


###  题目 03- 什么是 MVCC？

- Redo 日志

  -  redo日志, 是重做日志, 但数据丢失时, 可以从redo日志中恢复数据;
  
- ReadView

  -  ReadView是张存储事务id的表, 主要包含当前系统中有哪些活跃的读写事务, 把它们的事务id放到一个列表中, 主要包含以下四个字段;
     -  m_ids：表示在生成ReadView时，当前系统中活跃的读写事务id列表
     -  m_low_limit_id：事务id下限，表示当前系统中活跃的读写事务中最小的事务id，m_ids事务列表中的最小事务id
     -  m_up_limit_id：事务id上限，表示生成ReadView时，系统中应该分配给下一个事务的id值
     -  m_creator_trx_id：表示生成该ReadView的事务的事务id
     -  ![image-20231001210238665](.\附件\image-20231001210238665.png)

- 如何判断可见性

  -  开启事务执行第一次查询时，首先生成ReadView，然后依据Undo日志和ReadView按照判断可见性，按照下边步骤判断记录的版本链的某个版本是否可见。
  -  循环判断规则如下：
     -  如果被访问版本的 trx_id 属性值，小于ReadView中的事务下限id，表明生成该版本的事务在生成 ReadView 前已经提交，所以该版本可以被当前事务访问。
     -  如果被访问版本的 trx_id 属性值，等于ReadView中的 m_creator_trx_id ，可以被访问。
     -  如果被访问版本的 trx_id 属性值，大于等于ReadView中的事务上限id，在生成 ReadView 后才产生的数据，所以该版本不可以被当前事务访问。
     -  如果被访问版本的 trx_id 属性值，在事务下限id和事务上限id之间，那就需要判断是不是在m_ids 列表中。
        -  如果在，说明创建 ReadView 时生成该版本的事务还是活跃的，该版本不可以被访问；
        -  如果不在，说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问。
  
     -  循环判断Undo log中的版本链某一的版本是否对当前事务可见，如果循环到最后一个版本也不可见的话，那么就意味着该条记录对该事务不可见，查询结果就不包含该记录。
  
  
  





























