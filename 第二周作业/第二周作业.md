## JVM 虚拟机论述题

###  题目 01- 请你用自己的语言向我介绍 Java 运行时数据区（内存区域）

- 堆

   - 堆是线程共享的数据存储区域,
   - 主要存储对象数据,数组和运行时常量;  是垃圾回收的主要内存区域
   - 基于分代收集理论; 堆主要分为  年轻代,老年代;    年轻代又分为Eden区和两个Survivor区;

- 虚拟机栈

   - 虚拟机栈是程序执行的地方,  是属于线程独享的区域;
   - 一个线程中包含一个虚拟机栈.  栈中包含多个栈帧,
   - 栈帧是支持虚拟机进行方法调用的数据结构;
   - 栈帧存储了方法的局部变量表,方法返回地址,动态连接,操作数栈等信息;
   - 栈帧在方法被调用的时候创建(入栈);在方法执行完毕时销毁(出栈); 
   - 栈的最大深度取决于栈内存大小;
   - 栈顶的栈帧,称为当前栈帧,   执行引擎的所有字节码指令都是只针对当前栈帧进行操作的;

- 本地方法栈

   - 本地方法栈是为虚拟机与操作系统资源与硬件交互提交服务.  
   - 通过调用本地方法的方式与操作系统交互.
   - 本地方法栈也包含多个栈帧,  也有当前栈帧, 栈内的数据结构与虚拟机栈一致;

- 方法区

   - 方法区是线程共享的数据存储区域;
   - 主要存储编译后的代码;  存储类的结构信息;  
      - 如class字节码对象; 主要包含了:
      - class类型信息;
      - 方法信息, 如:参数,方法名称,方法返回值信息;
      - 字段信息,  如字段类型;
      - 方法表,类变量等;
   - 方法区的实现有两种方式,   永久代  和 元空间;
   - 永久代与元空间的区别主要在于存储位置 与存储内容不同;
   - 永久代使用的内存区域是jvm进程使用的内存区域,  永久代中有存储静态变量和运行时常量池;  而元空间没有存储 静态变量和运行时常量池;
   - 从jdk1.8开始有了元空间,去除了永久代;  元空间使用的是物理存储区域,不受分配给JVM内存大小的限制; 受计算机总体内存大小影响;
   - 元空间只存储类  编译后的字节码对象信息;

- 运行时常量池(字符串常量池)

   - 所有双引号的字符串都存在字符串常量池, 字符串常量池全局唯一;
   - 在编译期间,所有双引号修饰的字符串都会存储到,  字符串常量池中;  所有的运行常量池共享字符串常量池中的字符串;   
   - 运行时常量池有多个, 字符串常量池只有一个;
   - 一个class字节码对象,被加载到内存中,  就变成了运行时常量池;
   - 运行时常量池主要包含字面量 和符号引用;
   - 字面量是指常见的数值类型,如: Int ,float ,double , long 
   - 符号引用是指, 引用类型存储地址, 如: 对象指针, 方法指针, 字段指针等;

- 程序计数器;

   - 每个线程都有一个独立的程序计数器,  主要存储当前线程所执行的虚拟机字节码指令的地址;
   - 主要的作用时, 处理器在执行线程切换时,能恢复到线程执行的正确位置;为系统上下文切换提供服务;
   - 主要通过字节码解释器来改变这个程序计数器的值, 来选取下一条,需要执行的字节码指令;
   - 计数器存储的值, 是线程在执行java方法的字节码指令地址;  如果执行native方法, 都不会改变这个计数器的值;

- 直接内存

   - 直接内存是为了提升一些特殊场景的内存读写性能;
   - 直接内存是通过native函数库直接分配的堆外内存; 通过DirectByteBuffer对象进行操作; 此对象存储在堆中;
   - 直接内存主要服务于,频繁的读写文件的IO操作;   频繁的网络IO操作;
   - 直接内存的读写性能优于 堆内存;  
   - 直接内存的内存分配效率 低于 堆内存分配效率,  

- 为什么堆内存要分年轻代和老年代?

   - 主要是为垃圾回收期服务,  提高垃圾回收的时间效率,  提供内存的空间利用率;
   - 年轻代主要存储存活时间短的对象,  老年代主要存储难以被回收的对象;

   

### 题目 02- 描述一个 Java 对象的生命周期

- 解释一个对象的创建过程;
  - 当执行到new指令时,开始一个对象的创建;
  - 首先会去常量池检查类是否已经加载;
    - 未加载,   则通过类加载器,去加载类;
    - 已经加载,  则到下一步
  - 开始基于类的字节码信息为对象分配内存空间;
  - 内存空间分配完, 为对象的基本信息初始化默认值; 初始化为零值;
  - 为对象设置必要的信息, 对象头信息,  主要包含类的元数据,对象哈希码,GC分代年龄;
  - 执行init()  初始化对象完成;
  - 结束;
- 解释一个对象的内存分配;
  - 一个新对象申请堆内存空间时;
  - 首先判断 Eden区, 是否放得下
    - 是,则在年轻代中分配对象内存; 主要通过指针碰撞的方式, 为对象申请连续的内存空间,这种方式分配内存的效率高;
    - 否,则会触发一个 YoungGc,  回收垃圾对象; 
    - YoungGc之后,会把Eden元区存活的对象转移到Eden Survivor区,如果Eden Survivor区放得下的话;
  - 然后再次判断Eden区是否放得下
    - 放得下,  则在年轻代中分配对象内存;
    - 放不下, 则判断老年代是否放得下?
  - 如果放得下, 则在老年代分配对象的内存空间,主要通过连续空间的分配方式; 
  - 如果放不下,则触发 FullGc, 回收垃圾对象, 然后再次判断是否放得下?
    - 放得下,则在老年代分配对象的内存空间;
    - 如果放不下,  会再次触发FullGc,   这边循环判断触发FullGc会发生三次; 如果三次都放不下,  则会触发OOM异常;
- 解释一个对象的销毁过程;
  - 当一个对象没有被引用时, 就是垃圾对象,会被垃圾回收器销毁;
  - 垃圾回收器通过两种算法来找到要销毁的对象;
    - 引用计数法;
    - 根可达算法;
  - 对象被判断为垃圾对象后, 要经历两次标记过程, 才会被销毁;
  - 清除垃圾对象,主要通过三种算法来清除;
    - 标记清除算法
    - 拷贝算法
    - 标记压缩算法;
- 对象的2种访问方式是什么?
  - 句柄访问; 和直接指针访问;
    - 第一种,通过虚拟机栈的本地变量表,到堆内存的句柄池当中,找到对象的实例数据的指针,然后通过这个指针,  就可以找到实例池当中的对象数据; 同时也可以找到方法区, 的对象类型数据;
    - 第二种, 是虚拟机栈的本地变量表,直接存储的就是对象的指针, 然后通过这个对象的数据, 也可以找到方法区的对象类型数据;
- 为什么需要内存担保?
  - 内存担保是为了应对 堆内存中的新生代无法分配内存空间的这种情况
  - 当新生代无法分配内存空间时,需要把新生代的老对象转移到老年代, 然后把新对象放入腾空的新生代,

### 题目 03- 垃圾收集算法有哪些？垃圾收集器有哪些？他们的特点是什么？

- ParNew 收集器
  - 新生代并行收集器; 采用复制算法;
  - 用于新生代的垃圾回收;
  - 进行垃圾收集时,必须暂停其他所有的工作线程;
  - 复制算法清理的过程是:  将Eden和Survivor中还存活的对象拷贝到另外一个Survivor区, 最后清理掉Eden和Survivor用过的空间;
- ParallelScavenge 收集器
  - 是吞吐量优先收集器;目标是达到一个可控制的吞吐量;
  - 吞吐量 =  运行用户代码的时间/ (运行用户代码的时间 + 垃圾回收的时间 )
  - 用于新生代的垃圾回收, 是一个并行收集器; 采用复制算法;
- ParallelOld 收集器;
  - 跟ParallelScavenge 收集器有个相同的特定, 是主要吞吐量;
  - 用于老年代的垃圾回收, 是一个并行收集器; 采用标记-整理算法;
  - 主要适用于对CPU资源敏感的场合;
  - 垃圾回收的时候, 会暂停所有的用户线程;
  - 标记-整理算法,主要分为标记,清除,整理三个阶段; 
    - 首先标记出所有需要回收的垃圾对象, 
    - 然后在标记完成时,统一回收所有被标记的对象;
    - 然后将所有存货的对象往同一端移动, 然后直接清理掉端边界以外的内存;
- CMS收集器;
  - 是并发回收垃圾收集器;
  - 特点: 在标记和重新标记阶段需要暂停所有工作线程,  在最耗时的并发标记和并发清除阶段不需要暂停工作线程.
    - 低延迟, 减少暂停线程 对用户体验的影响;
    - 垃圾回收的触发点, 是参照堆内存的使用率的阈值
  - 采用标记-清除算法;
  - 回收会产生内存碎片, 可能导致并发清除后, 用户线程的可用内存空间不足;
- G1收集器;
  - G1垃圾收集器, 开创了面向布局收集的设计思路,  基于Region的内存布局的形式;
  - 适用于大内存的企业配置的服务器;
  - 使用标记-整理算法;
  - 可以配置垃圾收集的时间;
  - 不需要其他垃圾收集器配合,  可以独立管理整个堆内存的垃圾收集;



